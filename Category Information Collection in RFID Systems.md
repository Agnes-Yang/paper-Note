## abstract
在启用RFID的应用中，当标签被投入使用并且与特定对象相关联时，关于该对象的类别相关信息（例如，服装的品牌）可以根据需要被预加载到标签的存储器中。由于这些信息反映了分类属性，所以同一分类中的所有标签都携带相同的分类信息。为了收集这些信息，我们不需要重复询问每个标签;一个标签在一个类别中的响应就足够了。在本文中，我们研究了多类RFID系统中类别信息收集的新问题，即信息抽样。我们提出了一个有效的两阶段采样协议（TPS）。通过快速放大到一个类别并从这个类别中分离出一个标签，TPS能够通过只广播7.5位轮询矢量（与96位标签ID相比非常有效）来对一个类别进行采样。我们从理论上分析协议性能，并讨论最小化总体执行时间的最佳参数设置。大量的仿真表明，TPS的性能优于基准测试，大大提高了采样性能。

## introduction
无线电频率识别（RFID）在各种应用中变得无处不在，包括图书馆库存[1]，[2]，仓库管理[3] - [5]，对象跟踪[6]，[7]等。这些应用中，RFID标签通常被附加到属于不同类别的对象，例如图书馆中的书籍主题，药房中的药品类别，或者服装店中的衣服品牌。当一个标签与一个特定的对象相关联时，关于这个object1的与分类有关的信息很可能被预加载到标签的内存中。由于该信息反映了类别属性，因此同一类别中的每个标签携带相同的类别相关信息。

为了在多类RFID系统中收集类别信息，我们不需要重复询问每个标签。一个标签在一个类别中的回应就足够了。例如，如果我们想知道储存在仓库里的天然有机牛奶的生产商，我们只需要查询一个牛奶盒而不是全部，因为这种牛奶是由同一个生产商生产的。在另一个例子中，考虑一个冷藏食物储藏室，其中每个食物被固定有配备有热传感器的传感器增强型RFID标签（例如，WISP [8]）。阅读器周期性地从标签采样温度读数来检查是否有任何区域超出正常温度。由于属于同一类别的标签对象通常被打包在一起或紧密放置，因此来自附近标签的温度报告导致高数据冗余。因此，在这种情况下收集来自所有标签的传感器信息是一种浪费。

在本文中，我们研究了多类RFID系统中的类别信息收集问题，即信息抽样。为了解决这个问题，现有的工作[9] - [11]需要收集所有标签的信息，或者每隔一个感兴趣的标签时都要考虑整个标签集，从而导致耗时的收集过程。主要原因是这些解决方案是针对某些特定的应用而设计的，而不是针对具有两个新特征的采样问题：（i）由于同一类别中的标签携带相同的类别相关信息，所以我们不需要查询每个单独的标签。每个类别的一个标签响应足以报告相应的信息。 （ii）我们不关心某个类别中的哪个标签对读者有反应;该类别中的任何人都可以成为报告的候选人

通过考虑上述两个特点，我们提出了一个由两个阶段组成的有效的两阶段采样协议（TPS）。在第一阶段，读者将一个类别与其他类别分开，这有助于我们快速放大一个类别，而不是整个标签集合。在第二阶段，读者通过使用标签的几何分布，从分离的类别中分离任意标签。有效的两个步骤使得TPS远远优于现有的解决方案。我们分析协议性能并讨论最小化总体执行时间的最佳参数设置。理论分析和仿真结果表明，TPC能够通过仅广播7.5比特轮询矢量来采样一个类别，与96比特标签ID相比非常有效。本文的其余部分安排如下。第二节阐述抽样问题。第三部分提出了一个双相抽样协议。第四节评估所提出的协议的性能。第五节介绍相关工作。最后，第六节总结本文。

## 阐述抽样问题
A. System Model
我们考虑一个由阅读器和一些标签组成的RFID系统。每个标签都有一个唯一的标签ID，它唯一代表与其关联的单个对象。标签ID包含两个组件：表示标签属于哪个类别的类别ID，以及标识该类别中的特定成员的成员ID。具有相同类别标识的标签共享一些共同的信息，可以是标签投入使用时预先加载的静态类别相关信息（例如标签产品的品牌），也可以是动态监测信息（如传感器数据）是由附近的标签实时测量的。我们将这些信息称为类别信息。注意类别ID和类别信息之间的差异。前者是标签ID的一个子集，后者是一类商品的共同属性。由于芯片上资源有限，标签之间不能互相通信，而是可以通过单跳传输与阅读器进行通信。
B. Problem Definition
假设N是RFID系统中预先设定的标签集，其中n = | N |。 根据类别ID，将N划分为一系列不相交集合C = {C1，C2，...，Cm}，满足m i = 1Ci = N。 为了简单起见，我们使用Ci来表示类别ID以及该类别中的标签集合。 有m = | C | 总共的类别; N中的每个标签都属于其中之一。 抽样问题是以一种有效的方式从每个类别中收集一个或多个比特类别信息。 由于类别中的信息是相同的，所以不需要从所有标签收集信息。 每个类别中的任意标签响应足以报告所需的信息。
## TPS
A. Baseline Protocol
基本轮询（BP）作为一种常见的防冲突协议，提供了一种请求 - 响应的方式来在RFID系统中每次选出一个标签。 在BP中，读卡器广播一个标签的ID; 所有的标签都在不停地收听，只有唯一匹配的标签才会回复给读者。 BP的显着优势在于询问请求和响应是一对一映射; 在开放的无线信道中不会发生碰撞。 然而，广播标签ID（EPCglobal Gen2标准中的96位长）用于轮询每个标签是耗时的。 我们引用广播位（来自读者）来选出一个标签作为轮询矢量。 显然，在BP中，每个标签的轮询矢量是96位标签ID。 我们把它作为比较的基准

B. Basic Idea
抽样问题的一个更复杂的解决方案是随机选择不同类别的m个标签（用M表示），然后使用高级工作ETOP [11]从子集M中收集信息。但是，这种设计必须采取 每次询问标签时都考虑到整个标签集N，降低了采样效率（大概意思是，每次随机选取即采样都在整个集合里取）。 例如，ETOP中排序向量的大小必须设置得足够长以保证M之外的标签不被选中。 我们不是这样做，而是深入研究抽样问题的两个特点，并提出了一个两阶段的解决方案：1）将一个类别与其他类别分开; 2）在这个类别中挑出一个标签。 第一步可以帮助我们快速放大一个类别，而不是整个标签集。 第二步只使用4位索引根据标签ID的几何分布轮询单个标签。 有效的两个步骤组成了我们的远远优于BP和ETOP的TPS协议。

C. Protocol Description
TPS通常由几个抽样轮次组成，每个抽样轮次使用两个阶段（排序阶段和轮询阶段）对近30％的类别进行抽样。 排序阶段告诉标签是否以及何时参与这一轮，轮询阶段使用4位索引来将标签从类别中提取出。 详情如下

1) Ordering Phase:
读卡器首先通过广播一个带有参数f，r的请求来初始化帧，其中f是帧大小，r是随机种子。该帧是一个虚拟的帧，永远不会实际发出来。它只是作为一个工具来找出在这个帧中有用的插槽;只有由有用的插槽组成的实际帧将在稍后执行。

在接收到这个请求后，每个标签在H（cid，r）mod f的位置随机选择一个槽位，其中cid是标签的类别ID，H（·）是所有标签共享的散列函数。由于每个标签都采用类别ID而不是标签ID作为散列种子，因此来自同一类别的标签必须位于同一个插槽中。没有标签选择的插槽，仅来自单个类别的标签，来自多个类别的标签分别被称为空插槽，同类插槽和异类插槽。以图1为例。共有三类;同一类别中的标签散列到同一个槽位。第二个插槽是同类的，因为它是由单个类别C1中的标签选取的。相反，第四个时隙是不同的，因为它的三个标签（t2，t5和t6）来自两个不同的类别。左边是空的插槽。注意，这个阶段的帧大小f只与类别的数目m有关，而与标签的数量n无关，大大降低了通信开销。例如，每个类别平均有20个标签，m = 0.05n。稍后我们将讨论参数设置和协议开销。

存在于同类槽中的类别称为同类类别，相应的标签称为同类标签。在以下协议执行中，只有同类插槽可能会有用。当且仅当它是同类且可解的（我们将在轮询阶段给出可解析的时隙的定义）时，一个时隙（即插槽，slots）才是有用的。不符合上述要求的左侧插槽被称为无用插槽。每个标签不知道它选择的槽是否有用，但是读卡器可以。利用标签ID（包含类别ID）信息，读卡器可以预测虚拟框架中的哪些插槽是有用的。在执行实际的帧之前，它将删除无用的插槽。为此，读者广播一个f位的排序向量V [11]。 V中的每个比特对应于虚拟帧中的一个时隙：“0”指示无用，“1”指示有用。如果V太长，读卡器可以把它分成许多96位段，并在一个长度为tid的时隙中传输每个段[9]。

从标签的角度来看，排序矢量V携带两条信息。首先，标签可以通过检查V中的相应位来了解是否选择了一个有用的插槽。只有这样，标签才会参与下面的轮询阶段。另一方面，V告诉实际帧中有用时隙的索引。如果一个标签发现在它的位之前有i个位为V（即1），标签就知道它选择了第（i + 1）个有用的时隙

## 评估
